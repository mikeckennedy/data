{
  "copyright_text": null,
  "description": "You are a developer. Maybe you're building a rich web experience, like a\nsingle page app using JavaScript and a framework like React, Angular or\nVue. Maybe you have multiple clients besides web on mobile platforms\nlike iOS or Android. Maybe you have an external facing public API for\nuse by clients with many diverse needs. One things is for sure: you need\na robust API.\n\nThat API should be able to evolve over time to meet the growing and\nchanging demands of the business and your clients. The frameworks and\nparadigms we choose as we develop any software can help or hinder that\nchange. A well-designed GraphQL API enables flexibility and stability\nacross changes, as well as easy service discovery and thinner clients\nwith less responsibilities, ensuring that your application grows\nsuccessfully over time.\n\nThe tutorial will focus on building a GraphQL API using the **Python**\nlibrary **Graphene** with a **Django** backend as a vehicle for teaching\nthe principals of evolutionary API that can be applied across any tech\nstack, including REST, as well as the more practical concerns of working\nwith **Graphene** and designing your API for GraphQL.\n\nA frontend, built using **JavaScript** with **React** and the **Apollo**\nGraphQL client library, will be made available so users can understand\nthe full-stack considerations of building this API and reacting to\nevolving concerns over time. Writing JavaScript will not be required,\nbut being comfortable reading it and setting up a local environment will\nhelp get more out of this tutorial.\n\nWe'll attempt to answer questions such as:\n\n-  When is using GraphQL for an API most effective?\n-  How do I get started with GraphQL in Python?\n-  What does it mean for an API to be Relay-compliant? What benefits are\n   there? Drawbacks if we don't comply?\n-  How can we make use of field arguments for sorting, filtering and\n   other concerns?\n-  What kinds of changes are safe to make to my API as clients begin\n   consuming it?\n-  How can I ensure my GraphQL API performs well and we avoid the\n   dreaded *N+1 As A Service* problem?\n-  How should I design mutation responses for my GraphQL API to serve\n   client needs?\n-  How can multiple stakeholders decide how to evolve the API together?\n",
  "duration": 11516,
  "language": "eng",
  "recorded": "2019-05-02T09:00:00",
  "related_urls": [
    {
      "label": "Conference schedule",
      "url": "https://us.pycon.org/2019/schedule/talks/"
    },
    {
      "label": "Conference slides (speakerdeck)",
      "url": "https://speakerdeck.com/pycon2019"
    },
    {
      "label": "Conference slides (github)",
      "url": "https://github.com/PyCon/2019-slides"
    },
    {
      "label": "Talk schedule",
      "url": "https://us.pycon.org/2019/schedule/presentation/89/"
    }
  ],
  "speakers": [
    "Dave Anderson"
  ],
  "tags": [
    "tutorial"
  ],
  "thumbnail_url": "https://i.ytimg.com/vi/DWgD5iloSHs/maxresdefault.jpg",
  "title": "Building Evolutionary API with GraphQL and Python",
  "videos": [
    {
      "type": "youtube",
      "url": "https://www.youtube.com/watch?v=DWgD5iloSHs"
    }
  ]
}
