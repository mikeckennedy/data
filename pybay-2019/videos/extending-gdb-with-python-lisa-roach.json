{
  "description": "This talk was presented at PyBay2019 - 4th annual Bay Area Regional Python conference. See pybay.com for more details about PyBay and click SHOW MORE for more information about this talk.\n\nDescription\nGDB is powerful, and can be extended with Python to do more than just one-off debugging. This talk will describe using Python with GDB to with GDB to write tools that interact with running processes, highlighting GDB\u2019s ability to call C functions and how this can be coupled with Python\u2019s C-API to inject code without needing to stop the process.\n\nAbstract\nThe first half of the talk will be introductory in nature. I will talk about GDB and some of the specifics of how it can be extended with Python. The second half of the talk I will use the things discussed to create a program that does simple memory analysis of all objects in a running Python process.\n\nIntroduction- who I am, what this talk is about (1 min)\nGDB Introduction (3 min) a. What it is typically used for- debugging segfaults, etc b. How it works- ptrace under the hood c. Can execute C code (this will be important later in the talk) d. Source files (also important later in the talk)\nGDB Python API (6 min) a. Accessing Python from GDB: basic commands (python [command], source, py-list, etc) b. Accessing GDB from Python: To use GDB in Python, from a GDB process, you can import gdb and all of the API is available to you. The API has extensive options to allow for many types of analysis but I will focus on some of the more basic options: executing GDB CLI strings, setting GDB parameters, and creating custom GDB commands. Docs: https://sourceware.org/gdb/current/onlinedocs/gdb/Python-API.html#Python-API c. Show an example using gdb and Python\u2019s C-API: gdb.execute(\u2018call PyRun_SimpleString(\u201cprint(\u2018Hello World\u2019)\u201d)\u2019)\nProblem Statement: I want to know what objects are taking up the most memory in my program, but I don\u2019t want to (or more realistically, can\u2019t) add code to my process to do the data collection. Solution: Use GDB to inject into my running process some memory analysis code (we can use open-source projects like objgraph or pympler to do the memory work for us) and get that data back without killing the debugged process. (2 min)\nLaunch a GDB subprocess and attach to the running process we are interested in debugging. (2 min)\nIn the GDB subprocess command, connect to a Python script file that GDB can use as a \u2018source file\u2019. This file will be able to import gdb and use the GDB Python API to create custom commands. (1 mins)\nWrite a custom command by inheriting from gdb.Command and using gdb.execute with PyRun_SimpleString (3 mins)\nMemory analysis tools can be injected the same way as print(\u2018Hello World\u2019) using PyRun_SimpleString, but PyRun_SimpleString only likes one line at a time. To get around this, I place all the code I would like executed in another file, and have PyRun_SimpleString run an exec(file.read()) on the open file (3 mins)\nTwo gotchas: locking the GIL, and making sure the running process has access to the memory analysis modules (2 min)\nConclusion (2 min)\n\nOriginal slides: https://t.ly/3VX2b\n\nAbout the speaker\nLisa is a Production Engineer at Facebook and a CPython Core Developer. She is passionate about Python, and has spent time using Python on networking and security teams, and now focuses on improving the language itself and enabling other users of it.\n\nSponsor Acknowledgement\nThis and other PyBay2019 videos are via the help of our media partner AlphaVoice (https://www.alphavoice.io/)!\n\n#pybay #pybay2019 #python #python3 #gdb",
  "recorded": "2019-08-17",
  "speakers": [
    "Lisa Roach"
  ],
  "thumbnail_url": "https://i.ytimg.com/vi/xt9v5t4_zvE/hqdefault.jpg",
  "title": "Extending GDB with Python",
  "videos": [
    {
      "type": "youtube",
      "url": "https://www.youtube.com/watch?v=xt9v5t4_zvE"
    }
  ]
}
