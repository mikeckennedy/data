{
  "alias": "video/2939/practical-pybuilder",
  "category": "EuroPython 2014",
  "copyright_text": "http://creativecommons.org/licenses/by/3.0/",
  "description": "Why another build tool\n======================\n\nStarting up a simple python project with best practices still takes a\nlot of boilerplate and glueing (e.G. chaining unit tests and integration\ntests in the build process, adding a linter, measuring coverage, ...).\nIt often results in extremely ugly homebrew scripts and edge-case\nsolutions that are not reusable. There are even programs out there (e.G.\ncookiecutter) that encourage boilerplate code generation!\n\nBuild orchestration\n===================\n\nPyBuilder borrows from the *maven* idea of phases (packaging, verifying,\npublishing, ...) to set up a fully declarative and automated build that\ncan be run locally and remotely (build servers) in the very same way.\nRather than reinventing the wheel, it provides glue between existing\nsolutions (like unittest, coverage, flake8, ...) through a simple but\npowerful plugin mechanism.\n\nThe talk\n========\n\nAfter a more theoretical talk with a colleague at PyConDE 2013, I want\nto show how it's actually like to work with *PyBuilder*. This includes\n\n-  starting up a project\n-  running builds\n-  using plugins\n-  writing a plugin\n\nThe demo code will be made available on GitHub and I'll probably have\nrecordings prepped in case something goes wrong.\n\nReviewer FAQ\n============\n\nHow does PyBuilder compare to other existing solutions like zc.buildout?\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nAs opposed to solutions like zc.buildout which focus on the *building*\nof complex projects (many parts, complex dependencies) PyBuilder\nemphasizes the full build process for very simple projects. Undoubtedly,\nbuildout is more powerful for building in that regard and there is no\nreason to switch to PyBuilder.\n\nHowever, for simple projects (a few packages, pure python) we believe\nthat PyBuilder is better, especially if you're starting out with Python.\nThe plugin architecture (as opposed to recipes) makes it easier to\nreason about what is going on. We are able to model dependencies between\nbuild phases (like \"coverage\" needing \"unit tests\" and \"packaging\"\nneeding \"integration tests\") where recipes are not. It also seems (after\nlooking through the recipes available for buildout) that we have more\nfocus on QA as part of the build process (lint code, differentiate\nbetween unit/integration tests, code analysis, ...).\n\nThere is also a special focus on having the build descriptor written in\nPython (with fluent interfaces where possible) so that it is possible to\nunderstand what the configuration is by reading plain english, as\nopposed to zc.buildout (where the configuration is an ini file, or SCons\nwhich is very make-oriented).\n\nIn the end, a big difference between most build tools and PyBuilder is\nthat PyBuilder is more about orchestration. We didn't reinvent packaging\nor linting, we simply use what is already there (setuptools, flake8,\npymetrics, ...). This allows users to use the tools they want without\nhaving to do the integration themselves, and still get a nice, unified\nbuild process out of it.\n\nA simple example :\n\nIn buildout, code analysis can be done with\n\n::\n\n    [buildout]\n    parts += code-analysis\n\n    [code-analysis]\n    recipe = plone.recipe.codeanalysis\n    directory = ${buildout:directory}/src\n\nThis is not readable IMHO. In PyBuilder it can look like this :\n\n::\n\n    use_plugin('python.flake8')\n    project.set_property('flake8_include_test_sources', True)\n    project.set_property('flake8_ignore', 'E501')\n    project.set_property('flake8_break_build', True)\n\n\"It provides glue between existing build frameworks\" - which ones ? Could you name (some at least) ?\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nCurrently there is only a plugin for building with distutils/setuptools.\nShould that change (e.G. new contender) it would be easy to switch using\nPyBuilder.\n\nExamples where glue is needed :\n\n-  Glue setuptools + unittest, so that no distribution can be shipped if\n   tests fail\n-  Glue setuptools + coverage + unittest, so that no distribution can be\n   shipped if the statement coverage is too low (configurable ofc)\n-  Glue setuptools + pip so that cloned projects can be built with their\n   dependencies without needing to pip install manually\n\n",
  "duration": null,
  "id": 2939,
  "language": "eng",
  "quality_notes": "",
  "recorded": "2014-07-25",
  "slug": "practical-pybuilder",
  "speakers": [
    "Maximilien Riehl"
  ],
  "summary": "*PyBuilder* is a software build tool written in pure python which mainly\ntargets pure python applications. It provides glue between existing\nbuild frameworks, thus empowering you to focus on the big picture of the\nbuild process.\n\nIt will be shown through demonstrations and samples how a simple,\nhuman-readable and declarative configuration can lead to an\nastonishingly well-integrated build process which will make maintainers,\ndevelopers and newcomers happy.\n",
  "tags": [],
  "thumbnail_url": "https://i.ytimg.com/vi/iQU18hAjux4/hqdefault.jpg",
  "title": "Practical PyBuilder",
  "videos": [
    {
      "length": 0,
      "type": "youtube",
      "url": "https://www.youtube.com/watch?v=iQU18hAjux4"
    }
  ]
}
