{
  "description": "Why\n===\n\nThe audience will discover one of the core pieces of the language that\nsits at the middle of the decisions about what new rules can or cannot\nbe implemented in the Python programming language. They will learn how\nthe particularities of the grammar limit what can be achieved but also\nserve to maintain the language consistent, powerful but straightforward.\nAttendants will learn how core developers solved some challenging\nscenarios that arise as a consequence of said limitations or how others\ncannot be resolved unless Python gets a significant transformation in\nthe internal mechanism that parses the grammar. Finally, they will learn\nhow a new rule is added to the CPython grammar, serving as a perfect\nexample of how all the pieces come together. In summary, the audience\nwill gain a more technical response to why people perceive the Python\nprogramming language as easy but powerful one and at the same time will\ngain some insight on how to understand and extend the pieces that form\nit. This talk will not only help members of the audience understand\nbetter the design of the language a how grammars and parser work, but\nwill also help people wanting to contribute to CPython understanding the\ngeneral structure of the compiler pipeline and how to work on it.\n\nWho\n===\n\nThis talk is for those that want to understand Python a bit deeper: not\nonly how everything works under the hood but also what are the technical\ndecisions in its making and what are the consequences. The talk is\ntargeted to all Python programmers, no matter the skill level as\neveryone will find something for their particular level of expertise:\n\n- Beginner programmers will be introduced in the topic of language\n  grammars and will learn what a Grammar is and what are the building\n  blocks. Also, the audience members in this level will gain insight into\n  how everything is thread together in CPython.\n\n- Medium and advanced programmers will learn some in-depth technical\n  details and how they relate to features they already know and\n  understand. The talk not only will try to enlight some new areas related\n  to grammar technicalities, parser features and design and CPython\n  implementation details but will also connect many pieces of information\n  to explain how the small technical decisions impact the bigger picture.\n\nOutline\n=======\n\nWho am I\n\nWhat is the Python Grammar\n\n- What is grammar?\n- How they look like.\n- Elements: terminal symbols, nonterminal symbols, productions.\n\nThe properties of Python Grammar?\n\n- Leftmost derivation\n- 1 token lookahead\n- No epsilon productions! (Plus what epsilon productions are)\n- Some immediate consequences of these properties.\n\nHow the Python parser generator works\n\n- General structure of the parser generator.\n- Non Deterministic Finite Automata\n- Deterministic Finite Automata.\n- Some examples (with cool graphs!) generated from the\n  python grammar and the parser generator of the actual\n  finite automatas that Python uses.\n- Concrete syntax trees.\n\nAdvantages of the grammar (or \"why Python is so easy to understand)\n\n- LL(1) grammars are context-free (no state to maintain while\n  parsing).\n- LL(1) grammars are simple to implement and very fast to parse.\n- LL(1) grammars are very limited, keeping the language simple\n\nDisadvantages of the grammar:\n\n- Grammar ambiguity.\n- LL(1) grammars need some hacks for very simple things.\n- How keyword arguments were incorporated in the grammar with a hack:\n  The grammar rule is very strange because it is \"fixed\" in the Abstract\n  syntax tree\n- Why parenthesized with statements cannot be implemented (with\n  statements\n  formed of multiple elements surrounded by parenthesis and separated by\n  commas).\n\nImplementing a new grammar rule in CPython: the arrow operator :\n\n- A complete mini-tutorial on how to introduce a new operator: A -> B\n  that gets executed as A.\\ **rarrow**\\ (B).\n- Altering the grammar and generating the new parser.\n- Introducing a new token.\n- Changing the tokenizer.\n- Changing the Abstract Syntax Tree Generator.\n- Changing the compiler.\n- Implementing the new opcode.\n- Implementing the **rarrow** protocol.\n\nThe future and summary of the talk:\n\n- We have been discussing in the CPython discourse to change the\n  parser generator to something\n  more powerful.\n- Dangers and advantages of other parser generators.\n- What other implementations are using?\n- Summary of the talk\n",
  "language": "eng",
  "recorded": "2019-07-12",
  "speakers": [
    "Pablo Salgado"
  ],
  "tags": [
    "Abstractions",
    "CPython",
    "Performance",
    "python"
  ],
  "thumbnail_url": "https://i.ytimg.com/vi/1_23AVsiQEc/hqdefault.jpg",
  "title": "The soul of the beast",
  "videos": [
    {
      "type": "youtube",
      "url": "https://www.youtube.com/watch?v=1_23AVsiQEc"
    }
  ]
}
