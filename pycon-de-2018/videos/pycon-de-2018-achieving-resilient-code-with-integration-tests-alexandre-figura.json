{
  "abstract": "Writing good and isolated integration tests can be challenging. We will\nsee in this talk how to reach this goal, using Pytest and Docker\nCompose.\n\n*Tags:* Programming, Python\n\nScheduled on `wednesday 16:00 </schedule/#wed-16:00-lecture>`__ in room\nlecture\n",
  "copyright_text": null,
  "description": "You are maybe like me: I never learned at school how to write tests. My\nteachers gave me at first a broad overview of computer history. Then,\nthey explained me some basic design patterns. And to finish, I often had\nto write more or less basic programs, to validate and demonstrate my\nskills. Not the kind of code I would be really proud of today: the\nprocrastinator monkey living in my head at this time was more thinking\nabout planning my summer holidays, rather than writing Ninja code!\n\nAnd to make things worse, my studies focused on network and system\nengineering. Not software architecture. Funny story, because I decided\nto become programmer a couple of years later\u2026\n\nWhat I realize now is that I don\u2019t have as much time as before to learn.\nAnd in a world driven by business, where time is money, and where\ntradeoffs are the rule, there is rarely enough money to write both shiny\nnew features and a complete test suite.\n\nPeople who practice Test-Driven Development know how complicated it can\nbe to write proper tests. TDD is often discouraging at first: the\nlearning curve is steep. But this problem also exists in the testing\nworld in general. Because writing good tests is hard, many beginners get\nheadaches trying to reach this goal. How to convince project managers to\nhave more time for writing tests in these conditions\u2026\n\nBut \u201cle jeu en vaut la chandelle\u201d as we say in French (\"the juice is\nworth the squeeze\"). Well tested applications are not only easier to\nmaintain and extend. They also have in general a better API. That\u2019s what\nwe will see in this talk, by focusing on how to write integration tests.\nOur journey will begin with a presentation of different testing\nstrategies. We will then jump to the practical part, using Pytest,\ninterface testing , dependency injections and stubs, amongst many\nothers. And because we want to add nice buzzwords on our resume after\nPyConDE, we will finish this talk by automating the whole with Docker\nCompose.\n",
  "duration": 1862,
  "language": "eng",
  "recorded": "2018-10-24",
  "related_urls": [
    {
      "label": "Conference schedule",
      "url": "https://de.pycon.org/schedule/"
    }
  ],
  "speakers": [
    "Alexandre Figura"
  ],
  "tags": [
    "Programming",
    "Python"
  ],
  "thumbnail_url": "https://i.ytimg.com/vi/qRJ5qhblXV8/maxresdefault.jpg",
  "title": "Achieving Resilient Code with Integration Tests",
  "videos": [
    {
      "type": "youtube",
      "url": "https://www.youtube.com/watch?v=qRJ5qhblXV8"
    }
  ]
}
