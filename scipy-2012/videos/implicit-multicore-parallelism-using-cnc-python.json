{
  "alias": "video/1212/implicit-multicore-parallelism-using-cnc-python",
  "category": "SciPy 2012",
  "copyright_text": "CC BY-SA",
  "description": "We introduce CnC-Python (CP), an approach to implicit multicore\nparallelism for Python programmers based on a high-level macro data-flow\nprogramming model called Concurrent Collections (CnC). With the advent\nof the multi-core era, it is clear that improvements in application\nperformance will primarily come from increased parallelism. Extracting\nparallelism from applications often involves the use of low-level\nprimitives such as locks and threads. CP is implicitly parallel and\nenables programmers to achieve task, data and pipeline parallelism in a\ndeclarative fashion while only being required to describe the program as\na coordination graph with serial Python code for individual nodes\n(steps). Thus, CP makes parallel programming accessible to a broad class\nof programmers who are not trained in parallel programming. The CP\nruntime requires that Python objects communicated between steps be\npicklable, but imposes no restriction on the Python idioms used within\nthe serial code. Most data structures of interest to the SciPy\ncommunity, including NumPy arrays, are included in the class of\npicklable data structures in Python.\n\nThe CnC model is especially effective in exploiting parallelism in\nscientific applications in which the dependences can be represented as\narbitrary directed acyclic graphs (\"dag parallelism\"). Such applications\ninclude, but are not limited to, tiled implementations of iterative\nlinear algebra algorithms such as Cholesky decomposition, Gauss-Jordan\nelimination, Jacobi method, and Successive Over-Relaxation (SOR). Rather\nthan using explicit threads and locks to exploit parallelism, the\nCnC-Python programmer decomposes their algorithm into individual\ncomputation steps and identifies data and control dependences among the\nsteps to create such computation DAGs. Given the DAG (in the form of\ndeclarative constraints), it is the responsibility of the CP runtime to\nextract parallelism and performance from the application. By liberating\nthe scientific programmer, who is not necessarily trained to write\nexplicitly parallel programs, from the nuances of parallel programming,\nCP provides a high-productivity path for scientific programmers to\nachieve multi-core parallelism in Python.\n\nLINKS: CnC-Python: http://cnc-python.rice.edu Concurrent Collections:\nhttp://habanero.rice.edu/cnc\n",
  "duration": null,
  "id": 1212,
  "language": "eng",
  "quality_notes": "",
  "recorded": "2012-07-18",
  "related_urls": [
    "http://cnc-python.rice.edu",
    "http://habanero.rice.edu/cnc"
  ],
  "slug": "implicit-multicore-parallelism-using-cnc-python",
  "speakers": [
    "Shams Imam",
    "Vivek Sarkar"
  ],
  "summary": "",
  "tags": [
    "hpc"
  ],
  "thumbnail_url": "https://i3.ytimg.com/vi/ZC2pm2b_Sks/hqdefault.jpg",
  "title": "Implicit Multicore Parallelism using CnC-Python",
  "videos": [
    {
      "type": "mp4",
      "url": "http://s3.us.archive.org/nextdayvideo/enthought/scipy_2012/Implicit_Multicore_Parallelism_using_CnCPython.mp4?Signature=yyqfWPhoAeEggj1Sg1RiEE6k5jQ%3D&Expires=1346381702&AWSAccessKeyId=FEWGReWX3QbNk0h3"
    },
    {
      "length": 0,
      "type": "youtube",
      "url": "http://youtube.com/watch?v=ZC2pm2b_Sks"
    }
  ]
}
