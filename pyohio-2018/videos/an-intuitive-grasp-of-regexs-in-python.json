{
  "abstract": "Overview & Purpose\n------------------\n\nRegular expressions are used to define search patterns and are an\nimportant technique for validating data, scraping data, data wrangling,\n(i.e re- formatting.), the content of strings. Additionally, the\u2019re used\nto enable syntax highlighting in some applications. Python provides\nregular expressions via the built in \u2018re\u2019 module, and there is a third\nparty \u2018regex\u2019 module with added functionality. The problem is, writing\nregex patterns to do what you want is hard, and even when you\u2019ve got\none, figuring out what it is or isn\u2019t going to match can be baffling.\nThis talk will give you two tools conquer regex\u2019s, a mental model,\n(demonstrated with props), of how they work, and a mini-language,\n\u201cSimple Regex Language\u201d, to create readable regex\u2019s that easily\ntranslate into Python\u2019s regex syntax.\n\nA Physical Model of RegEx\u2019s\n---------------------------\n\n1. Picture the string we are searching as a line of tiles, (like those\n   in scrabble), where the character each represent has been routed into\n   its surface.\n2. This lets us talk about the two categories of places a regex start or\n   continue a match:\n3. At a character specified in the regex: (modeled by a vacuum-formed\n   sheet of plastic whose profile can nest in the character\u2019s incised\n   relief).\n4. At a position called an anchor, specified in the regex: (represented\n   by the insertion of a strip of plastic into the crack between tiles)\n\n   1. Note: whether a give \u2018crack\u2019 matches the given anchor is\n      determined by what is to its left and right; more specifically,\n      the categories they belong to, i.e. whitespace, printable,\n      alphabetic, numeric, eol, buffer-wall, etc.\n\n5. This model lets us illustrate how the regex engine goes about making\n   a match; e.g., if our pattern wants to match \u2018ABC\u2019, and our string\n   contains \u2018ABD\u2019, we slide along a piece of plastic with a \u2018A\u2019 profile,\n   from the start of the buffer to where we encounter the \u2018A\u2019 tile. The\n   plastic will sink into \u2018A\u2019 tile, allowing us to swing down \u2018B\u2019\n   plastic that is taped the the right edge of \u2018A\u2019 overlay which also\n   sinks down flush matching the \u2018B\u2019 tile. When we try to swing down the\n   next taped on plastic overlay, \u2018C\u2019, it crashes into the surface of\n   the \u2018D\u2019 tile and instead levers out the \u2018B\u2019 overlay, which levers out\n   the \u2018A\u2019 overlay and gets us back to sliding along the \u2018A\u2019 overlay\n   looking for the next place to pause and try for a match.\n6. At this point we introduce SRL, (below), then show how its patterns\n   translate into Python regex\u2019s, then we return to this model and\n   extend it to cover all the different regex \u2018atoms\u2019 we can now write.\n7. This \u201cTile and Overlay\u201d model provides a visual metaphor to see how\n   the regex engine works, but there are no tiles and overlay chains in\n   the computer, there are only strings of bytes and double-bytes, (if\n   we are talking UTF-8), so we briefly introduce a model that use\n   height to represent characters. This lets us talk about Unicode\n   strings, and hints at the kind of optimizations compiling regex\u2019s\n   might allow Python to do.\n8. For the presentation, there will be a physical model to show the\n   example in covered in point three above, but to make things\n   manageable, we'll then switch to illustrations done in Skecthup,\n   (maybe even animations).\n\nSRL: Simple Regex Language\n--------------------------\n\n1. SRL is what is known as a \u201cLittle Language\u201d, or a \u201cDomain Specific\n   Language\u201d which are built to handle a small problem area. In SRL\u2019s\n   case, the problem is that of the unreadability of regex\u2019s, and that\n   each language has a different way of writing them.\n2. You\u2019d think we could skip this as we are only concerned with Python\n   here, but it is useful to have this level of abstraction, even if you\n   only do Python. You are likely to find that your editor uses a\n   different flavor of regex\u2019s.\n3. An overview, live demos, and documentation can be found at the\n   project\u2019s website, https://simple-regex.com. I won\u2019t duplicate them\n   here,I\u2019ll just say that the exposition of what we need for this talk\n   will follow this source material, and include a SRL to Python cheat\n   sheet that covers their translation and how they are expressed in the\n   \u201cTile and Overlay\u201d model.\n4. To give reviewers a feel for what the illustration of SRL will look\n   like, I intend either add them to the proposal, or provide a link to\n   them on my github so you can look at them as they are created for\n   this talk.\n",
  "copyright_text": "Creative Commons Attribution license (reuse allowed)",
  "description": "Regular expressions are used to define search patterns. Python provides\nregular expressions via the built in \u2018re\u2019 module, but they are hard to\nread, write, and understand. This talk will give you two tools conquer\nregex\u2019s, a mental model, (demonstrated with props), of how they work,\nand a mini- language, \u201cSimple Regex Language\u201d, to create readable\nregex\u2019s that easily translate into Python regex's.\n",
  "duration": 2047,
  "language": "eng",
  "recorded": "2018-07-29",
  "related_urls": [
    {
      "label": "Conference schedule",
      "url": "https://www.pyohio.org/2018/schedule/"
    }
  ],
  "speakers": [
    "Tom Fetherston"
  ],
  "tags": [],
  "thumbnail_url": "https://i.ytimg.com/vi/O5gtgUQ0P_8/maxresdefault.jpg",
  "title": "An Intuitive Grasp of RegEx\u2019s in Python",
  "videos": [
    {
      "type": "youtube",
      "url": "https://www.youtube.com/watch?v=O5gtgUQ0P_8"
    }
  ]
}
