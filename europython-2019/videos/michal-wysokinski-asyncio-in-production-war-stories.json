{
  "description": "My team has been running AsyncIO in production for over 2 years now and\nthe only thing I can say about my experience with it is: \"Oh boy, what a\nrollercoaster of feelings\". I've experienced laughs and tears, sweat and\nblood but also sang songs of glory. AsyncIO is currently the biggest\nbuzzword in the Python world advertised as a silver bullet capable of\nsolving all Python's shortcomings in the field of performance. However,\nit also brings a burden of being a completely new approach with a fresh\nimplementation which is not often mentioned and taken into\nconsideration. In some of my team's projects we've achieved a great\nsuccess thanks to AsyncIO, but there's been a few where we decided to\nget rid of it and replace it with a more traditional fork-join\narchitecture. I'd like to share my experience with AsyncIO, tell some\nWar Stories and discuss which projects it suits perfectly and which ones\nshould avoid it.",
  "recorded": "2019-07-12",
  "speakers": [
    "Michal Wysokinski"
  ],
  "tags": [
    "ASYNC / Concurrency",
    "Debugging",
    "Python 3",
    "Use Case"
  ],
  "thumbnail_url": "https://i.ytimg.com/vi/EL5sg3A67mI/hqdefault.jpg",
  "title": "AsyncIO in production - War Stories",
  "videos": [
    {
      "type": "youtube",
      "url": "https://www.youtube.com/watch?v=EL5sg3A67mI"
    }
  ]
}
