{
  "description": "Two years ago, we began migrating from a proprietary service framework\nto a WSGI-compliant one. We chose uWSGI as our host because of its\nperformance and feature set. But, while powerful, uWSGI's defaults are\ndriven by backward compatibility and are not ideal for new deployments.\nPowerful features can be overlooked due to the sheer magnitude of its\nfeature set and spotty documentation. As we've scaled up the number of\nservices hosted by uWSGI over the last year, we've had to tweak our\nstandard configuration.\n\nIn this talk, we'll present the base uWSGI configuration we use as a\nstarting point for all services, as well as some tips to avoid known\ngotchas and provide a base level of defensiveness and high reliability.\nThis base configuration makes use of several \"no-cost\" uWSGI features\nthat help protect services from common, yet difficult to prevent issues\n-- some of which we discovered the hard way. We'll also talk about some\nprogrammatic uWSGI features which can be leveraged to improve\nreliability and improve outage response.\n\n| Some of the topics we'll cover include:\n| - Mitigating memory leaks\n| - Mitigating stuck, hung, or infinitely looping processes\n| - Preventing misconfigurations\n| - Preventing wasted development effort\n| - Improving outage response",
  "recorded": "2019-07-12",
  "speakers": [
    "Peter Sperl"
  ],
  "tags": [
    "Best Practice",
    "Distributed Systems",
    "Microservices",
    "Web Servers and MicroFWs",
    "failures/mistakes"
  ],
  "thumbnail_url": "https://i.ytimg.com/vi/3pNJDhD6v7A/hqdefault.jpg",
  "title": "Configuring uWSGI for Production: The defaults are all wrong",
  "videos": [
    {
      "type": "youtube",
      "url": "https://www.youtube.com/watch?v=3pNJDhD6v7A"
    }
  ]
}
